### 从保护模式返回实模式

#### 坑
既然386架构是对实模式的兼容，那么在实模式下，保护模式的段机制依然是存在的
只是“不可见”， 在cpu上电时，一开始初始位实模式，然而此时就已经是保护模式下的段
式寻址了，cs段描述符高速缓存寄存器的基址为段选择子左移四位，偏移初始为0ffffh，属性
为16位可读代码段，优先级为0， 其他所有段寄存器相应的高速缓存寄存器的属性为可读可写数据段
，优先级为0.

也就是说，在386架构下的cpu中的实模式是保护模式的一个子集

#### 段描述符高速缓存寄存器
在保护模式下，段寄存器中存放的是段选择子， 因此无法直接从段寄存器中获取物理
地址，为避免每一次寻址时，都去查询gdt表，每一个段寄存器都有一个相应的段描述符
高速缓存寄存器，只有当相应的段寄存器中的选择子改变时才去重新加载缓存寄存器，这样
能提高寻址效率

#### 回到正题
当打开A20地址线，关中断，修改cr0之后，我们可以从16位代码段跳入32位代码段，并且
由于开启了保护模式， 段描述符中包含段属性， 因此段描述符高速缓存寄存器可以在刷新时更新所有的内容， 然而，在由保护模式进入实模式后， 不再存在段描述符， 因此段描述符高速缓存寄存器只能刷新基址部分，其他部分无法更新并且也不会自动恢复到实模式的默认值，因此在进入实模式之前，必须要事先设置好所有段描述符高速缓存寄存器的段界限与段属性。

同样因为这个原因， 返回到实模式的段必须是16位的代码段，并且此段的段界限必须设置为0ffffh， 否则cpu无法正常工作。(其他所有段寄存器都可以手动更新，唯独段寄存器是无法手动更新的，因此只能在进入实模式之前就已确保当前段的界限和属性是正确的)
